//let v: Vec<u32> = vec![1, 2, 3];

/*
    看一下 vec! 宏的简单实现

    #[macro_export] 表明这个宏在它所在的包被引入作用域后才能使用，
    缺少这个标注的宏就不能被引入作用域

    宏名称是 vec
 */
// #[macro_export]
// macro_rules! vec {
//     /*
//         这里开始就是宏的定义体
//         这里类似于 match 的模式匹配（分支），而这里只有一个分支

//         ( $($x:expr), *) 就是它的匹配模式
//         => 后就是其对应的代码
        
//         这个宏只存在一种有效的匹配模式，其他模式都会导致编译时的错误
//         而某些比较复杂的宏他们就可能包含多个分支
//         这与 match 表达式还是有本质区别的，match 表达式它匹配的是值
//         而这里匹配的是 Rust 的代码结构

//         代码解释
//         $x:expr 表示可以匹配任何的 Rust 表达式，然后把它命名为 $x
//         , 意味着一个可能的逗号分隔符会出现在捕获代码的后边
//         * 表示能够匹配 0 个或多个 * 之前的东西
//         所以这个例子 ( $x:expr ), *) 就是匹配上边 1, 2, 3 这三个表达式  
//      */
//     ( $( $x:expr ), *) => {
//         {
//             let mut temp_vec = Vec::new();
//             $(
//                 /*
//                     每次匹配都会生成这样的代码
//                     本例就是：
//                     push(1)
//                     push(2)
//                     push(3)

//                  */
//                 temp_vec.push($x);
//             )*
//             // 返回 Vec
//             temp_vec 
//         }
//     };
// }




use proc_macro;

// 用来指定过程宏的占位符

#[some_attribute]
/*
    定义了过程宏的函数

    TokenStream 表示一段标记序列
    这也是过程宏的核心
    
    需要被宏处理的组成了参数 TokenStream
    结果 TokenStream 就是处理后的

    函数附带的属性就决定我们创建的是哪种过程宏
    同一个包中可以有多种不同的过程宏

 */
pub fn some_name(input: TokenStream) -> TokenStream {
    
}
